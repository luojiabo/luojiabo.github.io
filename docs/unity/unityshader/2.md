
# 第2章 渲染流水线

## 2.1 综述

### 2.1.1 什么是流水线

![](./images/2.1.PNG)

提高效率 专人做专事

### 2.1.2 渲染流水线

计算机将一些列顶点数据、纹理等信息转换成一张人眼可见的图像。

一个渲染流程分为应用阶段，几何阶段，光栅化阶段。
![](./images/2.2.PNG)

应用阶段（CPU）：准备场景数据（相机位置，视锥体，模型，光源等）->剔除->设置渲染状态（漫反射颜色，高光颜色，纹理，shader）->图元信息（点，线，面）。

几何阶段（GPU）：决定绘制的图元是什么，怎么绘制，在那里绘制。把顶点坐标转换到屏幕空间，再到光栅化。输出屏幕空间的二维坐标，顶点的深度值等。

光栅化（GPU）：根据数据产生屏幕上的像素。

## 2.2 CPU与GPU通讯

应用阶段3个阶段：

    （1）把数据加载到现存
    （2）设置渲染状态
    （3）电泳DrawCall

### 2.2.1 把数据加到显存

数据从硬盘加载到系统内存（RAM），网格和纹理等又被加载到显卡存贮空间-显存（VRAM）。
![](./images/2.3.PNG)

### 2.2.2 设置渲染状态

渲染状态：使用哪个着色器（顶点/片源着色器），光源属性，材质等。
如果没有更改，所有网络就使用同一种渲染状态。
![](./images/2.4.PNG)
所有工作准备好以后，调用DrawCall。

### 2.2.3 调用DrawCall

DrawCall：一个命令。指向被需要渲染的图元列表。
![](./images/2.5.PNG)

## 2.3 GPU流水线

GPU流水线：GPU渲染的过程。

### 2.3.1

![](./images/2.6.PNG)
    
GPU 的渲染流水线接收顶点数据作为输入。这些顶点数据是由应用阶段加
载到显存中，再由 Dra Call 指定的。这些数据随后被传递给顶点着色器。
顶点着色器 (Vertex Shader) 是完全可编程的，它通常用千实现顶点的空间变换 顶点着色等功能。 曲面细分着色器 (Tessellation Shader) 是一个可选的着色器，它用于细分图元。 几何着
色器 (Geometry Shader) 同样是一个可选的着色器，它可以被用于执行逐图元 Per-Pr itive
的着色操作，或者被用于产生更多的图元。下一个流水线阶段是裁剪 (Clipping), 这一阶段的目
的是将那些不在摄像机视野内的顶点裁剪掉，并剔除某些 角图元的面片。这个阶段是可配置的。
例如，我们可以使用自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正
面还是背面。几何概念阶段的最后一个流水线阶段是屏幕映射 (Screen Mapping) 。这 阶段是不
可配置和编程的，它负责把每个胆元的坐标转换到屏幕坐标系中。
光栅化概念阶段中的三角形设置 (Triangle Setup) 和三角形遍历 (Triangle Traversal) 阶段
也都是固定函数 (Fixed-Function) 的阶段。接下来的片元着色器 (Fragment Shader), 则是完全
可编程的，它用于实现逐片元 Per-Fragment 的着色操作。最后， 逐片元操作 (Per-Fragment
Operations) 段负责执行很多重要的操作，例如修改颜色、深度缓冲、进行混合等，它不是可
编程的，但具有很高的可配置性。

### 2.3.2 顶点着色器

顶点着色器需要完成的工作主要有：坐标变换和逐顶点光照。
把顶点坐标从模型空间转换到齐次裁剪空间。

### 2.3.3 裁剪

![](./images/2.9.PNG)


### 2.3.4 屏幕映射

输入的坐标仍然是三维坐标系下的坐标（范围在单位立方体内）。 屏幕映射 (Screen
Mapping) 的任务是把每个图元的 坐标转换到屏幕坐标系 (Screen Coordinates) 下

![](./images/2.10.PNG)

![](./images/2.11.PNG)

### 2.3.5 三角形设置

光栅化的第一个流水线阶段是三角形设置 (Triangle Setup) 。这个阶段会计算光栅化一个三角网格所需的信息。具体来说，上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个端点。但如果要得到整个三角网格对像素的覆盖情况 我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。

### 2.3.6 三角形遍历

三角形遍历 (Triangle Traversal) 阶段将会检查每个像素是否被 个三角网格所覆盖。如果被覆盖的话，就会生成一个片元 (fragment) 。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换 (Scan Conversion)角形遍历阶段会根据上 个阶段的计算结果来判断一个三角网格覆盖了哪些像素，并使用角网格 个顶点的顶点信息对整个覆盖区域的像素进行插值。
![](./images/2.12.PNG)
这一步的输出就是得到 个片元序列。需要注意的是，一个片元并不是真正意义上的像素
而是包含了很多状态的集合 这些状态用于计算每个像素的最终颜色。这些状态包括了（但不限于）它的屏幕坐标 深度信息，以及其他从几何阶段输出的顶点信息 例如法线、纹理坐标等。
### 2.3.7 片元着色器

片元着色器的输入是上 个阶段对顶点信息插值得到的结果 更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。而它的输出是 个或者多个颜色值。
![](./images/2.13.PNG)

### 2.3.8 逐片元操作

终于到了渲染流水线的最后 步。 逐片元操作 (Per Fragment Operations) OpenGL 中的说法 Direct.X 这一阶段被称为输出合井阶段 (Output-Merger)。

这一阶段有几个主要任务

    1、决定每个片元的可见性。这涉及了很多测试工作，例如深度测试、模板测试等
    2、如果一个片元通过了所有的测试 就需要把这个片元的颜色值和已经存储在颜色缓冲区颜色进行合并 或者说是混合。

![](./images/2.14.PNG)

![](./images/2.15.PNG)

我们先来看模板测试 Stencil Test) 。与之相关的是模板 Stencil Buffer 。实际上，模板缓冲和我 经常听到的颜色缓冲 、深度缓冲儿乎 类东西。如果开启了模板测试， GPU 会首先读取（使用读取掩码 ）模板缓冲区中该片元位置 的模板值，然 将该值和读取（使用读取掩码）到的参考值 reference value) 进行比较，这个比较函数可以是由开发者 的，例如小 舍弃该片元 或者大于等于时舍弃该片元。如果这个片元没有通过这个测试 该片元就会被舍弃。不个片元有没有通过模板测试，我 都可以根据模板测试和下面的深度测试结果来修改模板缓冲区，这个修改操作也是由开发者指定的。开发者可以设置不同结果下的修改操作 ，例如， 在失败时模板缓冲区保持不变，通过时将模板缓冲区中对应位置的值加 等。模板测试通常用千限制渲染的区域。另外，模板测试还有一些更高级的用法 如渲染阴影、轮廓渲染等。如果一个片元幸运地通过了模板测试，那么它会进行下一个测试－深度测试 (Depth Test)相信很多读者都听到过这个测试。这个测试同样是可以高度配笠的。如果开启了深度测试， GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。这个比较函数也是可由开发者设置的，例如小于时舍弃该片元，或者大于等于时舍弃该片元。通常这个比较函数是小于等千的关系，即如果这个片元的深度值大于等于当前深度缓冲区中的值，那么就会舍弃它。这是因为，我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的就不衙要出现在屏幕上。如果这个片元没有通过这个测试，该片元就会被舍弃。和模板测试有些不同的是，如果一个片元没有通过深度测试 它就没有权利更改深度缓冲区中的值。而如果它通过了测试，开发者还可以指定是否要用这个片元的深度值覆盖掉原有的深度值 这是通过开启／关闭深度写入来做到的。我们在后面的学习中会发现 透明效果和深度测试以及深度写入的关系非常密切。如果一个幸运的片元通过了上面的所有测试，它就可以自豪地来到合井功能的面前。为什么需要合并？我们要知道，这里所讨论的渲染过程是一个物体接着一个物体画到屏幕的。而每个像素的颜色信息被存储在一个名为颜色缓冲的地方。因此，当我们执行这次渲染时颜色缓冲中往往已经有了上次渲染之后的颜色结果，那么，我们是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理？这就是合并需要解决的问题。对于不透明物体，开发者可以关闭混合 (Blend) 操作。这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明物体，我们就需要使用混合操作来让这个物体看起来是透明的。图 2.16 展示了 一个简化版的混合操作的流程图。
![](./images/2.16.PNG)

从流程图中我们可以发现，混合操作也是可以高度配置的：开发者可以选择开启／关闭混合功
能。 如果没有开启混合功能， 就会直接使用片元的颜色覆盖掉颜色缓冲区中的颜色， 而这也是很
多初学者发现无法得到透明效果的原因（没有开启混合功能）。 如果开启了混合， GPU 会取出源
颜色和目标颜色， 将两种颜色进行混合。 源颜色指的是片元着色器得到的颜色值， 而目标颜色则
是已经存在于颜色缓冲区中的颜色值。 之后， 就会使用一个混合函数来进行混合操作。 这个混合
函数通常和透明通道息息相关， 例如根据透明通道的值进行相加、 相减、 相乘等。 混合很像
Photoshop 中对图层的操作：每一层图层可以选择混合模式，混合模式决定了该图层和下层图层的
混合结果， 而我们看到的图片就是混合后的图片。
当模型的图元经过了上而层层计算和测试后， 就会显示到我们的屏湍上。 我们的屏幕显示的
就是颜色缓冲区中的颜色值。 但是，为了避免我们看到那些正在进行光栅化的图元，GPU 会使用
双重缓冲 (Double Buffering) 的策略。这意味着，对场景的渲染是在器后发生的， 即在后置缓冲
(Back Buffer) 中。 一旦场景已经被渲染到了后置缓冲中， GPU 就会交换后置缓冲区和前置缓冲
(Front Buffer) 中的内容， 而前置缓冲区是之前显示在屏幕上的图像。 由此， 保证了我们看到的
图像总是连续的。
### 2.3.9 总结
![](./images/2.18.PNG)
## 2.4 容易困惑的地方

## 2.5 明白了吗

## 2.5 扩展